{% extends "user/base.html" %}

{% block content %}

<h1>{{ workflow.name }}</h1>
<p>{{ spec.meta.description }}</p>

<form method="post" action="/user/workflows/{{ workflow.slug }}/run" enctype="multipart/form-data">

    <button type="submit">Run workflow</button>

    {# ---------------------------
       1) VISIBLE GROUPS FIRST
       --------------------------- #}
    {% for g in visible_groups %}
        <div style="margin: 16px 0; padding: 14px; border: 1px solid #eee; border-radius: 12px; max-width: 980px;">
            <h3 style="margin: 0 0 10px 0;">{{ g.label }}</h3>

            {# TEXT #}
            {% for inp in g.text %}
                {% if inp.view != 'no_view' %}
                    <div style="margin-bottom: 14px;">
                        <label><b>{{ inp.label }}</b></label><br>
                        <textarea
                            name="text__{{ inp.key }}"
                            rows="4"
                            style="width: 100%;"
                            {% if inp.required %}required{% endif %}
                        >{{ inp.default | default("") }}</textarea>
                    </div>
                {% else %}
                    <input type="hidden" name="text__{{ inp.key }}" value="{{ inp.default | default('') }}">
                {% endif %}
            {% endfor %}

            {# PARAMS visible #}
            {% for p in g.params_view %}
                <div style="margin-bottom: 12px;">
                    <label><b>{{ p.label }}</b></label><br>
                    {% if p.type == 'text' %}
                        {% if g.label == 'Prompt Translate (Multiline Next Prompts)' %}
                            <textarea
                                name="param__{{ p.key }}"
                                rows="4"
                                style="width: 100%;"
                                {% if p.required %}required{% endif %}
                            >{{ p.default | default("") }}</textarea>
                        {% else %}
                            <input type="text" name="param__{{ p.key }}" value="{{ p.default | default('') }}" style="width: 360px;">
                        {% endif %}
                    {% else %}
                        <input type="number" name="param__{{ p.key }}" value="{{ p.default }}" step="any" style="width: 220px;">
                    {% endif %}
                </div>
            {% endfor %}

            {# PARAMS hidden in per-group accordion (only if group also has visible fields) #}
            {% if g.params_hidden and g.params_hidden|length > 0 %}
                <details style="margin-top: 12px; padding: 10px; border: 1px dashed #ddd; border-radius: 10px;">
                    <summary style="cursor: pointer; font-weight: 600;">
                        Advanced settings ({{ g.params_hidden|length }})
                    </summary>

                    <div style="margin-top: 12px;">
                        {% for p in g.params_hidden %}
                            <div style="margin-bottom: 12px;">
                                <label>{{ p.label }}</label><br>
                                {% if p.type == 'text' %}
                                    <input type="text" name="param__{{ p.key }}" value="{{ p.default | default('') }}" style="width: 360px;">
                                {% else %}
                                    <input type="number" name="param__{{ p.key }}" value="{{ p.default }}" step="any" style="width: 220px;">
                                {% endif %}
                            </div>
                        {% endfor %}
                    </div>
                </details>
            {% endif %}

            {# PARAMS no_view -> hidden inputs to be sent #}
            {% for p in g.params_no_view %}
                <input type="hidden" name="param__{{ p.key }}" value="{{ p.default }}">
            {% endfor %}

            {# IMAGES #}
            {% for img in g.images %}
                {% if img.view != 'no_view' %}
                    <div style="margin-top: 10px;">
                        <label><b>{{ img.label }}</b></label><br>
                        <input type="file" name="image__{{ img.key }}" accept="image/*" required>
                        <div class="preview" data-preview-for="image__{{ img.key }}" style="margin-top:6px;display:none;">
                            <img style="max-width:260px;max-height:260px;border:1px solid #ddd;border-radius:10px;" />
                        </div>
                    </div>
                {% endif %}
            {% endfor %}
        </div>
    {% endfor %}

    {# MASK отдельно #}
    {% if spec.inputs.mask %}
        <div id="mask-group"
             data-depends-on="{{ spec.inputs.mask.depends_on }}"
             data-required="{{ '1' if spec.inputs.mask.required else '0' }}"
             style="margin: 16px 0; padding: 14px; border: 1px solid #eee; border-radius: 12px; max-width: 980px;">
            <h3 style="margin: 0 0 10px 0;">
                {{ spec.inputs.mask.label or 'Mask' }}
                {% if spec.inputs.mask.required %}<span style="color:#c00;">*</span>{% endif %}
            </h3>
            <div style="margin-bottom: 8px; color:#666; font-size: 13px;">
                depends_on: <b>{{ spec.inputs.mask.depends_on }}</b>
            </div>
            <input type="file" name="mask" accept="image/*">
            <div class="preview" data-preview-for="mask" style="margin-top:6px;display:none;">
                <img style="max-width:260px;max-height:260px;border:1px solid #ddd;border-radius:10px;" />
            </div>

            <div id="mask-editor" style="display:none; margin-top:12px;">
                <div style="display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap;">
                    <div style="position:relative; display:inline-block; border:1px solid #ddd; border-radius:12px; overflow:hidden;">
                    <canvas id="mask-base" style="display:block;"></canvas>
                    <canvas id="mask-paint" style="position:absolute; left:0; top:0; cursor:crosshair;"></canvas>
                    </div>

                    <div style="min-width:240px; border:1px solid #eee; border-radius:12px; padding:12px;">
                    <div style="font-weight:600; margin-bottom:8px;">Mask tools</div>

                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button type="button" id="tool-brush">Brush</button>
                        <button type="button" id="tool-eraser">Eraser</button>
                    </div>

                    <div style="margin-bottom:10px;">
                        <label>Brush size: <span id="brush-size-val">32</span></label><br/>
                        <input type="range" id="brush-size" min="1" max="200" value="32" style="width:100%;">
                    </div>

                    <div class="mask-extra" style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; margin-bottom:10px;">
                        <label style="display:flex; gap:8px; align-items:center;">
                            <span style="white-space:nowrap;">Overlay</span>
                            <input id="maskOverlayOpacity" type="range" min="0.1" max="0.8" step="0.05" value="0.35">
                            <span id="maskOverlayOpacityVal">0.35</span>
                        </label>

                        <button type="button" id="maskInvertBtn">Invert mask</button>
                    </div>

                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button type="button" id="mask-undo">Undo</button>
                        <button type="button" id="mask-clear">Clear</button>
                    </div>

                    <div style="margin-bottom:10px;">
                        <button type="button" id="mask-apply" style="width:100%;">Use drawn mask</button>
                    </div>

                    <div style="color:#666; font-size:12px;">
                        White = masked area, Black = no mask.
                    </div>
                    </div>
                </div>
            </div>

        </div>
    {% endif %}

    {# --------------------------------------------------------
       2) ONE GLOBAL ACCORDION FOR "HIDDEN-ONLY" GROUPS
       (groups where there were no view/text/image, only hidden)
       -------------------------------------------------------- #}
    {% if hidden_only_groups and hidden_only_groups|length > 0 %}
        <details style="margin: 18px 0; padding: 14px; border: 1px dashed #ddd; border-radius: 12px; max-width: 980px;">
            <summary style="cursor: pointer; font-weight: 700;">
                Advanced settings ({{ hidden_only_groups|length }} groups)
            </summary>

            <div style="margin-top: 14px;">
                {% for g in hidden_only_groups %}
                    <div style="margin: 14px 0; padding: 12px; border: 1px solid #eee; border-radius: 12px;">
                        <h4 style="margin: 0 0 10px 0;">{{ g.label }}</h4>

                        {# text in hidden-only groups (rare), but handle #}
                        {% for inp in g.text %}
                            {% if inp.view != 'no_view' %}
                                <div style="margin-bottom: 14px;">
                                    <label><b>{{ inp.label }}</b></label><br>
                                    <textarea
                                        name="text__{{ inp.key }}"
                                        rows="4"
                                        style="width: 100%;"
                                        {% if inp.required %}required{% endif %}
                                    >{{ inp.default | default("") }}</textarea>
                                </div>
                            {% else %}
                                <input type="hidden" name="text__{{ inp.key }}" value="{{ inp.default | default('') }}">
                            {% endif %}
                        {% endfor %}

                        {# hidden params #}
                        {% for p in g.params_hidden %}
                            <div style="margin-bottom: 12px;">
                                <label>{{ p.label }}</label><br>
                                {% if p.type == 'text' %}
                                    <input type="text" name="param__{{ p.key }}" value="{{ p.default | default('') }}" style="width: 360px;">
                                {% else %}
                                    <input type="number" name="param__{{ p.key }}" value="{{ p.default }}" step="any" style="width: 220px;">
                                {% endif %}
                            </div>
                        {% endfor %}

                        {# if somehow params_view appear here, render too #}
                        {% for p in g.params_view %}
                            <div style="margin-bottom: 12px;">
                                <label><b>{{ p.label }}</b></label><br>
                                {% if p.type == 'text' %}
                                    <input type="text" name="param__{{ p.key }}" value="{{ p.default | default('') }}" style="width: 360px;">
                                {% else %}
                                    <input type="number" name="param__{{ p.key }}" value="{{ p.default }}" step="any" style="width: 220px;">
                                {% endif %}
                            </div>
                        {% endfor %}

                        {# no_view params must still be sent #}
                        {% for p in g.params_no_view %}
                            <input type="hidden" name="param__{{ p.key }}" value="{{ p.default }}">
                        {% endfor %}

                        {# images in hidden-only groups (rare), but handle #}
                        {% for img in g.images %}
                            {% if img.view != 'no_view' %}
                                <div style="margin-top: 10px;">
                                    <label><b>{{ img.label }}</b></label><br>
                                    <input type="file" name="image__{{ img.key }}" accept="image/*" required>
                                    <div class="preview" data-preview-for="image__{{ img.key }}" style="margin-top:6px;display:none;">
                                        <img style="max-width:260px;max-height:260px;border:1px solid #ddd;border-radius:10px;" />
                                    </div>
                                </div>
                            {% endif %}
                        {% endfor %}
                    </div>
                {% endfor %}
            </div>
        </details>
    {% endif %}

    <!-- <button type="submit">Run workflow</button> -->
</form>

<script>
    // --- previews ---
    function setPreview(inputEl) {
        const name = inputEl.getAttribute('name');
        const box = document.querySelector(`.preview[data-preview-for="${CSS.escape(name)}"]`);
        if (!box) return;
        const img = box.querySelector('img');
        const f = inputEl.files && inputEl.files[0];
        if (!f) {
            box.style.display = 'none';
            img.removeAttribute('src');
            return;
        }
        const url = URL.createObjectURL(f);
        img.src = url;
        box.style.display = 'block';
    }

    document.querySelectorAll('input[type=file]').forEach((inp) => {
        inp.addEventListener('change', () => setPreview(inp));
    });

    // --- mask depends_on logic ---
    const maskGroup = document.getElementById('mask-group');
    if (maskGroup) {
        const dependsOn = maskGroup.getAttribute('data-depends-on');
        const baseInputName = `image__${dependsOn}`;
        const baseInput = document.querySelector(`input[type=file][name="${CSS.escape(baseInputName)}"]`);

        function syncMaskVisibility() {
            // если base image не найден — не скрываем (лучше показать, чем потерять)
            if (!baseInput) {
                maskGroup.style.display = '';
                return;
            }

            const baseSelected = baseInput.files && baseInput.files.length > 0;
            maskGroup.style.display = baseSelected ? '' : 'none';

            // если поле скрыли — очищаем выбранную маску
            if (!baseSelected) {
                const maskInput = maskGroup.querySelector('input[type=file][name="mask"]');
                if (maskInput) {
                    maskInput.value = '';
                    setPreview(maskInput);
                }
            }
        }

        if (baseInput) {
            baseInput.addEventListener('change', syncMaskVisibility);
        }
        syncMaskVisibility();

        (function () {
            const maskGroup = document.getElementById('mask-group');
            if (!maskGroup) return;

            const dependsOn = maskGroup.getAttribute('data-depends-on');
            const baseInputName = `image__${dependsOn}`;
            const baseInput = document.querySelector(`input[type=file][name="${CSS.escape(baseInputName)}"]`);
            const maskInput = maskGroup.querySelector(`input[type=file][name="mask"]`);

            const editor = document.getElementById('mask-editor');
            const canvasBase = document.getElementById('mask-base');
            const canvasPaint = document.getElementById('mask-paint');
            if (!editor || !canvasBase || !canvasPaint || !maskInput) return;

            const ctxBase = canvasBase.getContext('2d', { willReadFrequently: true });
            const ctxPaint = canvasPaint.getContext('2d', { willReadFrequently: true });

            // Реальная маска хранится отдельно (offscreen)
            const maskBuf = document.createElement('canvas');
            const ctxMask = maskBuf.getContext('2d', { willReadFrequently: true });

            // Настройка overlay (как подсветка)
            function getOverlayColor() {
                const a = overlayOpacity ? Number(overlayOpacity.value || 0.35) : 0.35;
                return `rgba(255, 0, 0, ${a})`;
            }

            const btnBrush = document.getElementById('tool-brush');
            const btnEraser = document.getElementById('tool-eraser');
            const rangeSize = document.getElementById('brush-size');
            const sizeVal = document.getElementById('brush-size-val');
            const btnUndo = document.getElementById('mask-undo');
            const btnClear = document.getElementById('mask-clear');
            const overlayOpacity = document.getElementById('maskOverlayOpacity');
            const overlayOpacityVal = document.getElementById('maskOverlayOpacityVal');
            const btnInvert = document.getElementById('maskInvertBtn');
            const btnApply = document.getElementById('mask-apply');

            let tool = 'brush';
            let brushSize = parseInt(rangeSize.value || '32', 10);
            let drawing = false;
            let lastX = 0, lastY = 0;

            // 1-step undo (MVP). Можно расширить в stack.
            let undoImageData = null;

            function redrawOverlay() {
                const w = canvasPaint.width, h = canvasPaint.height;
                ctxPaint.clearRect(0, 0, w, h);

                // Рисуем цветную заливку
                ctxPaint.save();
                ctxPaint.fillStyle = getOverlayColor();
                ctxPaint.fillRect(0, 0, w, h);

                // Оставляем заливку только там, где маска НЕ прозрачная
                ctxPaint.globalCompositeOperation = 'destination-in';
                ctxPaint.drawImage(maskBuf, 0, 0);
                ctxPaint.restore();
            }

            if (overlayOpacity && overlayOpacityVal) {
                overlayOpacityVal.textContent = String(overlayOpacity.value);

                overlayOpacity.addEventListener('input', () => {
                    overlayOpacityVal.textContent = String(overlayOpacity.value);
                    redrawOverlay();
                });
            }

            function invertMask() {
                const w = maskBuf.width, h = maskBuf.height;
                if (!w || !h) return;

                snapshotUndo();

                const img = ctxMask.getImageData(0, 0, w, h);
                const d = img.data;

                // Мы рисуем белым в маску (rgb=255, alpha=255), фон прозрачный (alpha=0)
                // Инверт: alpha = 255 - alpha, rgb оставим белым.
                for (let i = 0; i < d.length; i += 4) {
                    d[i] = 255;     // R
                    d[i + 1] = 255; // G
                    d[i + 2] = 255; // B
                    d[i + 3] = 255 - d[i + 3]; // A
                }

                ctxMask.putImageData(img, 0, 0);
                redrawOverlay();
            }

            if (btnInvert) {
                btnInvert.addEventListener('click', () => {
                    invertMask();
                });
            }

            function setTool(t) {
                tool = t;
                btnBrush.disabled = (t === 'brush');
                btnEraser.disabled = (t === 'eraser');
            }

            function setBrushSize(v) {
                brushSize = v;
                sizeVal.textContent = String(v);
            }

            setTool('brush');
            setBrushSize(brushSize);

            rangeSize.addEventListener('input', () => setBrushSize(parseInt(rangeSize.value, 10)));

            btnBrush.addEventListener('click', () => setTool('brush'));
            btnEraser.addEventListener('click', () => setTool('eraser'));

            function snapshotUndo() {
                try {
                    undoImageData = ctxMask.getImageData(0, 0, maskBuf.width, maskBuf.height);
                } catch (e) {
                    undoImageData = null;
                }
            }

            btnUndo.addEventListener('click', () => {
                if (!undoImageData) return;
                ctxMask.putImageData(undoImageData, 0, 0);
                redrawOverlay();
            });

            btnClear.addEventListener('click', () => {
                snapshotUndo();
                ctxMask.clearRect(0, 0, maskBuf.width, maskBuf.height); // прозрачная маска
                redrawOverlay();
            });

            function getPos(evt) {
                const rect = canvasPaint.getBoundingClientRect();
                const x = (evt.clientX - rect.left) * (canvasPaint.width / rect.width);
                const y = (evt.clientY - rect.top) * (canvasPaint.height / rect.height);
                return { x, y };
            }

            function strokeLine(x0, y0, x1, y1) {
                ctxMask.save();
                ctxMask.lineCap = 'round';
                ctxMask.lineJoin = 'round';
                ctxMask.lineWidth = brushSize;

                if (tool === 'brush') {
                    ctxMask.globalCompositeOperation = 'source-over';
                    ctxMask.strokeStyle = '#fff'; // белая маска
                } else {
                    // eraser: стираем до прозрачности
                    ctxMask.globalCompositeOperation = 'destination-out';
                    ctxMask.strokeStyle = 'rgba(0,0,0,1)';
                }

                ctxMask.beginPath();
                ctxMask.moveTo(x0, y0);
                ctxMask.lineTo(x1, y1);
                ctxMask.stroke();
                ctxMask.restore();

                redrawOverlay();
            }

            function onPointerDown(evt) {
                if (!editor || editor.style.display === 'none') return;
                drawing = true;
                snapshotUndo();
                const p = getPos(evt);
                lastX = p.x; lastY = p.y;
                strokeLine(lastX, lastY, lastX, lastY);
                canvasPaint.setPointerCapture(evt.pointerId);
            }

            function onPointerMove(evt) {
                if (!drawing) return;
                const p = getPos(evt);
                strokeLine(lastX, lastY, p.x, p.y);
                lastX = p.x; lastY = p.y;
            }

            function onPointerUp(evt) {
                drawing = false;
                try { canvasPaint.releasePointerCapture(evt.pointerId); } catch (e) {}
            }

            canvasPaint.addEventListener('pointerdown', onPointerDown);
            canvasPaint.addEventListener('pointermove', onPointerMove);
            canvasPaint.addEventListener('pointerup', onPointerUp);
            canvasPaint.addEventListener('pointercancel', onPointerUp);
            canvasPaint.addEventListener('pointerleave', onPointerUp);

            async function loadBaseImageFromFile(file) {
                return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
                });
            }

            async function setupEditorFromBaseImage() {
                if (!baseInput || !baseInput.files || !baseInput.files[0]) {
                editor.style.display = 'none';
                return;
                }

                const img = await loadBaseImageFromFile(baseInput.files[0]);

                // 1) Реальный размер канваса = размер исходника
                canvasBase.width = img.naturalWidth;
                canvasBase.height = img.naturalHeight;
                canvasPaint.width = img.naturalWidth;
                canvasPaint.height = img.naturalHeight;

                // 2) Визуальный размер: ограничим, чтобы не раздувало страницу
                const maxW = 768;
                const scale = Math.min(1, maxW / img.naturalWidth);
                canvasBase.style.width = Math.round(img.naturalWidth * scale) + 'px';
                canvasBase.style.height = Math.round(img.naturalHeight * scale) + 'px';
                canvasPaint.style.width = canvasBase.style.width;
                canvasPaint.style.height = canvasBase.style.height;

                // 3) Рисуем базу + инициализируем маску чёрным
                ctxBase.clearRect(0, 0, canvasBase.width, canvasBase.height);
                ctxBase.drawImage(img, 0, 0);

                // подгоняем maskBuf под размер
                maskBuf.width = img.naturalWidth;
                maskBuf.height = img.naturalHeight;

                // пустая маска (прозрачная)
                ctxMask.clearRect(0, 0, maskBuf.width, maskBuf.height);

                // и рисуем overlay (пока пустой)
                redrawOverlay();

                editor.style.display = '';
            }

            // Важное: показываем редактор только если base image выбран (depends_on логика)
            async function syncEditor() {
                if (!baseInput || !baseInput.files || baseInput.files.length === 0) {
                editor.style.display = 'none';
                return;
                }
                await setupEditorFromBaseImage();
            }

            if (baseInput) baseInput.addEventListener('change', () => { syncEditor(); });

            // Кнопка "Use drawn mask" -> file input "mask"
            btnApply.addEventListener('click', async () => {
                const w = maskBuf.width, h = maskBuf.height;

                // temp canvas для экспорта (чёрный фон + белая маска)
                const out = document.createElement('canvas');
                out.width = w; out.height = h;
                const outCtx = out.getContext('2d');

                outCtx.fillStyle = '#000';
                outCtx.fillRect(0, 0, w, h);
                outCtx.drawImage(maskBuf, 0, 0);

                const blob = await new Promise((resolve) => out.toBlob(resolve, 'image/png'));
                if (!blob) return;

                const file = new File([blob], 'mask.png', { type: 'image/png' });

                const dt = new DataTransfer();
                dt.items.add(file);
                maskInput.files = dt.files;

                if (typeof setPreview === 'function') setPreview(maskInput);
            });

            // первичная синхронизация
            // (mask-group сам скроется/покажется, а мы — редактор)
            syncEditor();
        })();
    }
</script>

{% endblock %}
